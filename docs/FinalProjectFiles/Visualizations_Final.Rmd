---
title: "Visualizations"
author: "Aiden Kim"
date: "2025-05-04"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(repos = c(CRAN = "https://cloud.r-project.org"))
```

```{r libraries, message=FALSE, warning=FALSE}
# Install packages if needed (uncomment if necessary)
# install.packages(c("shiny", "ggplot2", "plotly", "scales", "RColorBrewer", "dplyr", "shinydashboard", "reshape2"))

# Load libraries
library(shiny)
library(ggplot2)
library(plotly)
library(scales)
library(RColorBrewer)
library(dplyr)
library(shinydashboard)
library(reshape2)
```

```{r ui_definition}
ui <- dashboardPage(
  dashboardHeader(title = "NBA Elite Player Analysis"),
  
  dashboardSidebar(
    sidebarMenu(
      menuItem("Overview", tabName = "overview", icon = icon("dashboard")),
      menuItem("Player Efficiency", tabName = "per", icon = icon("chart-line")),
      menuItem("Two-Way Analysis", tabName = "twoway", icon = icon("balance-scale")),
      menuItem("Efficiency vs. Usage", tabName = "efficiency", icon = icon("percentage")),
      menuItem("Player Comparison", tabName = "comparison", icon = icon("users")),
      menuItem("About", tabName = "about", icon = icon("info-circle"))
    ),
    
    # Add filters that apply across tabs
    hr(),
    h4("Filters"),
    sliderInput("min_games", "Minimum Games Played:", 
                min = 20, max = 82, value = 50),
    sliderInput("min_minutes", "Minimum Minutes Per Game:", 
                min = 10, max = 40, value = 20),
    selectInput("positions", "Positions:", 
                choices = c("All", "PG", "SG", "SF", "PF", "C"),
                selected = "All", multiple = TRUE),
    hr(),
    
    # Player selection for comparison
    h4("Player Comparison"),
    selectizeInput("player_select", "Select Players to Compare:",
                   choices = NULL, multiple = TRUE, options = list(maxItems = 5))
  ),
  
  dashboardBody(
    tabItems(
      # Overview tab
      tabItem(tabName = "overview",
        fluidRow(
          box(
            title = "NBA Elite Player Analysis", status = "primary", solidHeader = TRUE,
            width = 12,
            h3("Who is the Best NBA Player?"),
            p("This interactive dashboard explores NBA player performance through the lens of advanced analytics."),
            p("Navigate through the tabs to explore different metrics and visualizations that help identify the NBA's elite players."),
            p("Use the filters on the left to customize your analysis by minimum games played, minutes per game, and positions.")
          )
        ),
        fluidRow(
          valueBoxOutput("total_players_box", width = 4),
          valueBoxOutput("top_per_box", width = 4),
          valueBoxOutput("top_vorp_box", width = 4)
        ),
        fluidRow(
          box(
            title = "Top Players by PER", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("top_per_plot", height = 400)
          ),
          box(
            title = "Top Players by Win Shares", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("top_ws_plot", height = 400)
          )
        )
      ),
      
      # Player Efficiency tab
      tabItem(tabName = "per",
        fluidRow(
          box(
            title = "Player Efficiency Rating (PER) Analysis", status = "primary", solidHeader = TRUE,
            width = 12,
            p("PER is a per-minute rating that sums up all a player's positive accomplishments, subtracts the negative, and returns a per-minute rating of a player's performance."),
            p("PER above 20.0 is considered excellent, above 15.0 is average.")
          )
        ),
        fluidRow(
          box(
            title = "Top Players by PER", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("per_leaders", height = 400)
          ),
          box(
            title = "PER vs. Win Shares", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("per_vs_ws", height = 400)
          )
        ),
        fluidRow(
          box(
            title = "PER Distribution by Position", status = "info", solidHeader = TRUE,
            width = 12,
            plotlyOutput("per_by_position", height = 400)
          )
        )
      ),
      
      # Two Way Analysis tab
      tabItem(tabName = "twoway",
        fluidRow(
          box(
            title = "Two-Way Player Analysis", status = "primary", solidHeader = TRUE,
            width = 12,
            p("The best players in the NBA excel on both ends of the court. This analysis identifies players who contribute significantly on both offense and defense.")
          )
        ),
        fluidRow(
          box(
            title = "Offensive vs. Defensive Rating", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("off_def_rating", height = 400)
          ),
          box(
            title = "Two-Way Score Analysis", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("two_way_score", height = 400)
          )
        ),
        fluidRow(
          box(
            title = "Defensive Impact Metrics", status = "info", solidHeader = TRUE,
            width = 12,
            plotlyOutput("defensive_impact", height = 400)
          )
        )
      ),
      
      # Efficiency vs. Usage tab
      tabItem(tabName = "efficiency",
        fluidRow(
          box(
            title = "Scoring Efficiency vs. Usage Analysis", status = "primary", solidHeader = TRUE,
            width = 12,
            p("This section examines the relationship between scoring efficiency and usage rate. Elite players maintain high efficiency despite high usage rates.")
          )
        ),
        fluidRow(
          box(
            title = "True Shooting % vs. Usage Rate", status = "info", solidHeader = TRUE,
            width = 12,
            plotlyOutput("ts_usage", height = 500)
          )
        ),
        fluidRow(
          box(
            title = "Points Per Shot vs. Shots Per Game", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("pts_per_shot", height = 400)
          ),
          box(
            title = "Efficiency Metrics by Position", status = "info", solidHeader = TRUE,
            width = 6,
            plotlyOutput("efficiency_by_position", height = 400)
          )
        )
      ),
      
      # Player Comparison tab
      tabItem(tabName = "comparison",
        fluidRow(
          box(
            title = "Player Statistical Comparison", status = "primary", solidHeader = TRUE,
            width = 12,
            p("This interactive tool allows you to compare selected players across multiple statistical categories."),
            p("Select players from the dropdown menu on the left to include them in the comparison.")
          )
        ),
        fluidRow(
          box(
            title = "Statistical Profile Comparison", status = "info", solidHeader = TRUE,
            width = 12,
            plotlyOutput("player_comparison", height = 500)
          )
        ),
        fluidRow(
          box(
            title = "Detailed Stats Table", status = "info", solidHeader = TRUE,
            width = 12,
            dataTableOutput("stats_table")
          )
        )
      ),
      
      # About tab
      tabItem(tabName = "about",
        fluidRow(
          box(
            title = "About This Project", status = "primary", solidHeader = TRUE,
            width = 12,
            h3("NBA Elite Player Analysis"),
            p("This interactive dashboard was created as a final project for MATH 230: Data Visualization & Computing."),
            p("The analysis uses advanced NBA statistics to identify and compare the league's best players through multiple analytical lenses."),
            h4("Data Source:"),
            p("NBA player statistics from the 2024-25 regular season."),
            h4("Analytics Approach:"),
            p("This application combines traditional box score statistics with advanced metrics to provide a comprehensive view of player performance."),
            p("Key metrics examined include:"),
            tags$ul(
              tags$li("Player Efficiency Rating (PER)"),
              tags$li("Value Over Replacement Player (VORP)"),
              tags$li("Win Shares (WS)"),
              tags$li("True Shooting Percentage (TS%)"),
              tags$li("Usage Rate"),
              tags$li("Offensive and Defensive Ratings")
            ),
            h4("Contact:"),
            p("For questions or feedback about this project, please contact Aiden Kim.")
          )
        )
      )
    )
  )
)
```

```{r server_function}
# Server function
server <- function(input, output, session) {
  
  # Load and preprocess data
  data <- reactive({
    # Read the data
    nba_data <- read.csv("nba_data_processed.csv", stringsAsFactors = FALSE)
    
    # Filter based on user inputs
    filtered_data <- subset(nba_data, G >= input$min_games & MP >= input$min_minutes)
    
    # Apply position filter if not "All"
    if (!("All" %in% input$positions) && length(input$positions) > 0) {
      # Create a function to check if a position matches any selected position
      position_match <- function(pos) {
        any(sapply(input$positions, function(p) grepl(p, pos)))
      }
      filtered_data <- filtered_data[sapply(filtered_data$Pos, position_match), ]
    }
    
    # Calculate additional advanced metrics
    filtered_data$TS_Pct <- filtered_data$PTS / (2 * (filtered_data$FGA + 0.44 * filtered_data$FTA)) * 100
    filtered_data$USG_Pct <- (filtered_data$FGA + 0.44 * filtered_data$FTA + filtered_data$TOV) / (filtered_data$MP / 5) * 100
    filtered_data$BPM_approx <- (filtered_data$PTS + 2.2 * filtered_data$STL + 0.7 * filtered_data$BLK + 
                                 0.3 * filtered_data$AST + 0.7 * filtered_data$DRB + 
                                 0.3 * filtered_data$ORB - 0.6 * filtered_data$FGA - 
                                 0.6 * filtered_data$FTA - 0.4 * filtered_data$PF - 
                                 filtered_data$TOV) / filtered_data$G
    filtered_data$VORP_approx <- filtered_data$BPM_approx * (filtered_data$MP / (48 * 82)) * 2.7
    filtered_data$WS_approx <- (filtered_data$PTS * 0.037 + filtered_data$STL * 0.138 + 
                               filtered_data$BLK * 0.095 + filtered_data$ORB * 0.034 + 
                               filtered_data$DRB * 0.034 + filtered_data$AST * 0.048 - 
                               filtered_data$FGA * 0.029 - filtered_data$FTA * 0.015 - 
                               filtered_data$TOV * 0.034 - filtered_data$PF * 0.020) * filtered_data$G
    filtered_data$PER_approx <- (filtered_data$PTS + 2.7 * filtered_data$STL + 
                                0.7 * filtered_data$BLK + 0.7 * filtered_data$AST + 
                                0.3 * filtered_data$ORB + 0.3 * filtered_data$DRB - 
                                0.7 * filtered_data$TOV - 0.4 * filtered_data$PF) / filtered_data$MP * 36
    filtered_data$ORtg_approx <- (filtered_data$PTS / (filtered_data$FGA + 
                                 0.44 * filtered_data$FTA + filtered_data$TOV)) * 100
    filtered_data$DRtg_approx <- 110 - (filtered_data$STL * 0.5 + filtered_data$BLK * 0.5 + 
                                       filtered_data$DRB * 0.1) * 100 / filtered_data$MP
    
    # Create simplified position categories
    simplify_position <- function(pos) {
      if (grepl("PG", pos)) return("PG")
      if (grepl("SG", pos)) return("SG")
      if (grepl("SF", pos)) return("SF")
      if (grepl("PF", pos)) return("PF")
      if (grepl("C", pos)) return("C")
      return(pos)  # Default case
    }
    filtered_data$SimplifiedPos <- sapply(filtered_data$Pos, simplify_position)
    
    # Create offensive and defensive scores for two-way analysis
    filtered_data$Offensive_Score <- (filtered_data$PTS + filtered_data$AST*2) / 
                                    max(filtered_data$PTS + filtered_data$AST*2, na.rm = TRUE)
    filtered_data$Defensive_Score <- (filtered_data$STL + filtered_data$BLK + filtered_data$DRB) / 
                                    max(filtered_data$STL + filtered_data$BLK + filtered_data$DRB, na.rm = TRUE)
    
    # Calculate Points Per Shot
    filtered_data$PTS_per_Shot <- filtered_data$PTS / filtered_data$FGA
    
    return(filtered_data)
  })
  
  # Update player selection dropdown based on filtered data
  observe({
    players <- sort(data()$Player)
    updateSelectizeInput(session, "player_select", choices = players, 
                        selected = head(players[order(data()$PER_approx, decreasing = TRUE)], 5))
  })
  
  # Overview tab outputs
  output$total_players_box <- renderValueBox({
    valueBox(
      nrow(data()), "Qualified Players", 
      icon = icon("users"), color = "blue"
    )
  })
  
  output$top_per_box <- renderValueBox({
    top_player <- data()[which.max(data()$PER_approx), ]
    valueBox(
      top_player$Player, "Top PER Player", 
      icon = icon("trophy"), color = "yellow"
    )
  })
  
  output$top_vorp_box <- renderValueBox({
    top_player <- data()[which.max(data()$VORP_approx), ]
    valueBox(
      top_player$Player, "Top VORP Player", 
      icon = icon("award"), color = "green"
    )
  })
  
  # Top PER Plot
  output$top_per_plot <- renderPlotly({
    top_per <- head(data()[order(-data()$PER_approx), ], 10)
    p <- ggplot(top_per, aes(x = reorder(Player, PER_approx), y = PER_approx, fill = PER_approx)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      scale_fill_gradientn(colors = brewer.pal(9, "Blues")) +
      labs(x = NULL, y = "Player Efficiency Rating") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("y", "x"))
  })
  
  # Top Win Shares Plot
  output$top_ws_plot <- renderPlotly({
    top_ws <- head(data()[order(-data()$WS_approx), ], 10)
    p <- ggplot(top_ws, aes(x = reorder(Player, WS_approx), y = WS_approx, fill = WS_approx)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      scale_fill_gradientn(colors = brewer.pal(9, "Greens")) +
      labs(x = NULL, y = "Win Shares") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("y", "x"))
  })
  
  # Player Efficiency tab outputs
  output$per_leaders <- renderPlotly({
    top_per <- head(data()[order(-data()$PER_approx), ], 15)
    p <- ggplot(top_per, aes(x = reorder(Player, PER_approx), y = PER_approx, fill = SimplifiedPos)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      scale_fill_brewer(palette = "Set1") +
      labs(x = NULL, y = "Player Efficiency Rating", fill = "Position") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("y", "x", "fill"))
  })
  
  output$per_vs_ws <- renderPlotly({
    p <- ggplot(data(), aes(x = PER_approx, y = WS_approx, color = SimplifiedPos, size = MP)) +
      geom_point(alpha = 0.7) +
      scale_color_brewer(palette = "Set1") +
      labs(x = "Player Efficiency Rating", y = "Win Shares", color = "Position", size = "Minutes Played") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("x", "y", "color", "text" = "Player"))
  })
  
  output$per_by_position <- renderPlotly({
    p <- ggplot(data(), aes(x = SimplifiedPos, y = PER_approx, fill = SimplifiedPos)) +
      geom_boxplot(alpha = 0.7) +
      geom_jitter(width = 0.2, alpha = 0.5) +
      scale_fill_brewer(palette = "Set1") +
      labs(x = "Position", y = "Player Efficiency Rating", fill = "Position") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("y", "text" = "Player"))
  })
  
  # Two Way Analysis tab outputs
  output$off_def_rating <- renderPlotly({
    p <- ggplot(data(), aes(x = ORtg_approx, y = DRtg_approx, color = PTS, size = MP, text = Player)) +
      geom_point(alpha = 0.7) +
      scale_color_gradientn(colors = brewer.pal(9, "YlOrRd")) +
      scale_size_continuous(range = c(2, 10)) +
      labs(x = "Offensive Rating", y = "Defensive Rating (lower is better)", 
           color = "Points Per Game", size = "Minutes Played") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("x", "y", "color", "size", "text"))
  })
  
  output$two_way_score <- renderPlotly({
    p <- ggplot(data(), aes(x = Offensive_Score, y = Defensive_Score, color = SimplifiedPos, 
                            size = PER_approx, text = Player)) +
      geom_point(alpha = 0.7) +
      scale_color_brewer(palette = "Set1") +
      labs(x = "Offensive Score (normalized)", y = "Defensive Score (normalized)", 
           color = "Position", size = "PER") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("x", "y", "color", "size", "text"))
  })
  
  output$defensive_impact <- renderPlotly({
    p <- ggplot(data(), aes(x = STL, y = BLK, color = SimplifiedPos, size = DRB, text = Player)) +
      geom_point(alpha = 0.7) +
      scale_color_brewer(palette = "Set1") +
      labs(x = "Steals Per Game", y = "Blocks Per Game", 
           color = "Position", size = "Defensive Rebounds") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("x", "y", "color", "size", "text"))
  })
  
  # Efficiency vs. Usage tab outputs
  output$ts_usage <- renderPlotly({
    p <- ggplot(data(), aes(x = USG_Pct, y = TS_Pct, color = PTS, size = MP, text = Player)) +
      geom_point(alpha = 0.7) +
      scale_color_gradientn(colors = brewer.pal(9, "YlOrRd")) +
      scale_size_continuous(range = c(2, 10)) +
      labs(x = "Usage Rate (%)", y = "True Shooting Percentage (%)", 
           color = "Points Per Game", size = "Minutes Played") +
      theme_minimal() +
      # Add reference line for league average TS%
      geom_hline(yintercept = mean(data()$TS_Pct, na.rm = TRUE), linetype = "dashed", color = "gray50")
    
    ggplotly(p, tooltip = c("x", "y", "color", "size", "text"))
  })
  
  output$pts_per_shot <- renderPlotly({
    p <- ggplot(data(), aes(x = FGA, y = PTS_per_Shot, color = SimplifiedPos, text = Player)) +
      geom_point(alpha = 0.7) +
      scale_color_brewer(palette = "Set1") +
      labs(x = "Field Goal Attempts Per Game", y = "Points Per Shot", color = "Position") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("x", "y", "color", "text"))
  })
  
  output$efficiency_by_position <- renderPlotly({
    # Calculate mean efficiency metrics by position
    position_metrics <- list(SimplifiedPos = unique(data()$SimplifiedPos))
    
    # Check which percentage columns exist in the data
    pct_columns <- c("FG.", "3P.", "FT.", "TS_Pct", "eFG.")
    existing_cols <- pct_columns[pct_columns %in% names(data())]
    
    # Calculate metrics for each existing column
    for(col in existing_cols) {
      position_metrics[[col]] <- sapply(position_metrics$SimplifiedPos, function(pos) {
        mean(data()[data()$SimplifiedPos == pos, col], na.rm = TRUE)
      })
    }
    
    # Create data frame from the list
    pos_efficiency <- as.data.frame(position_metrics)
    
    # Ensure we have at least one metric column besides SimplifiedPos
    if(ncol(pos_efficiency) <= 1) {
      # If no metrics are available, just return a message
      return(plot_ly() %>% add_annotations(
        text = "No percentage metrics available for this selection",
        showarrow = FALSE
      ))
    }
    
    # Determine which columns we actually have for plotting
    available_cols <- names(pos_efficiency)[names(pos_efficiency) != "SimplifiedPos"]
    
    # Create long format data
    eff_long <- reshape2::melt(pos_efficiency, id.vars = "SimplifiedPos", 
                            measure.vars = available_cols)
    
    # Create plot
    p <- ggplot(eff_long, aes(x = SimplifiedPos, y = value, fill = variable)) +
      geom_bar(stat = "identity", position = "dodge") +
      scale_fill_brewer(palette = "Set2") +
      labs(x = "Position", y = "Percentage", fill = "Metric") +
      theme_minimal()
    
    ggplotly(p, tooltip = c("x", "y", "fill"))
  })
  
  # Player Comparison tab outputs
  output$player_comparison <- renderPlotly({
    filtered_data <- data()
    
    selected_players <- input$player_select
    if (length(selected_players) == 0) {
      selected_players <- head(filtered_data[order(-filtered_data$PER_approx), ]$Player, 5)
    }
    
    selected_data <- subset(filtered_data, Player %in% selected_players)
    
    if(nrow(selected_data) == 0) {
      return(plot_ly() %>% add_annotations(text = "No players match selection", showarrow = FALSE))
    }
    
    # Select stats to compare
    compare_stats <- c("PTS", "AST", "TRB", "STL", "BLK", "TS_Pct", "PER_approx", "WS_approx")
    
    # Scale the values for comparison (0-1 scale)
    scaled_data <- selected_data[, c("Player", compare_stats)]
    for(stat in compare_stats) {
      max_val <- max(filtered_data[[stat]], na.rm = TRUE)
      scaled_data[[stat]] <- scaled_data[[stat]] / max_val
    }
    
    # Convert to long format
    long_data <- reshape2::melt(scaled_data, id.vars = "Player", 
                               variable.name = "Metric", value.name = "Value")
    
    # Create parallel coordinates plot
    p <- ggplot(long_data, aes(x = Metric, y = Value, group = Player, color = Player)) +
      geom_line(size = 1.2) +
      geom_point(size = 3) +
      scale_color_brewer(palette = "Set1") +
      labs(x = "Statistical Category", y = "Value (normalized)", color = "Player") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
    
    ggplotly(p, tooltip = c("color", "y", "x"))
  })
    
  output$stats_table <- renderDataTable({
    # Get current filtered data
    filtered_data <- data()
    
    # If no players selected, use top 5 by PER
    selected_players <- input$player_select
    if (length(selected_players) == 0) {
      selected_players <- head(filtered_data[order(-filtered_data$PER_approx), ]$Player, 5)
    }
    
    # Get data for selected players
    selected_data <- subset(filtered_data, Player %in% selected_players)
    
    # If no players match the selection, return an empty data frame with a message
    if(nrow(selected_data) == 0) {
      return(data.frame(Message = "No players match selection"))
    }
    
    # Select columns to display (using column names that exist in your dataset)
    display_cols <- c("Player", "Pos", "Age", "G", "MP", "PTS", "AST", "TRB", "STL", "BLK")
    
    # Add additional columns only if they exist
    additional_cols <- c("FG.", "3P.", "FT.", "eFG.", "TS_Pct", "PER_approx", "WS_approx", "VORP_approx")
    existing_cols <- additional_cols[additional_cols %in% names(filtered_data)]
    
    display_cols <- c(display_cols, existing_cols)
    
    # Create the stats table
    stats_table <- selected_data[, display_cols]
    
    # Rename columns for display
    col_names <- c("Player", "Position", "Age", "Games", "Minutes", "Points", "Assists", 
                 "Rebounds", "Steals", "Blocks")
    
    additional_names <- c("FG%", "3P%", "FT%", "eFG%", "TS%", "PER", "Win Shares", "VORP")
    existing_names <- additional_names[1:length(existing_cols)]
    
    col_names <- c(col_names, existing_names)
    
    colnames(stats_table) <- col_names
    
    stats_table
  })
  
} # End of server function
```

```{r run_app}
# Run the Shiny app
shinyApp(ui = ui, server = server)
```